const { Pool } = require('pg');

// Database Configuration
const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: { rejectUnauthorized: false }, // Required for Supabase
    max: 25, // Increased pool size for better concurrency
    idleTimeoutMillis: 60000, // Increased from 30s to 60s
    connectionTimeoutMillis: 10000, // Increased from 2s to 10s for production
});

// Connection pool health monitoring
let poolConnectCount = 0;
let poolDisconnectCount = 0;

// Test connection
pool.on('connect', () => {
    poolConnectCount++;
    console.log(`âœ… Database connected (Total connections: ${poolConnectCount})`);
});

pool.on('remove', () => {
    poolDisconnectCount++;
    console.log(`ğŸ”Œ Database connection removed (Total removed: ${poolDisconnectCount})`);
});

pool.on('error', (err) => {
    console.error('âŒ Unexpected database pool error:', err.message);
});

// Initialize database tables with better error handling
async function initDb() {
    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        const createTableQuery = `
        CREATE TABLE IF NOT EXISTS leads (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          phone VARCHAR(20) UNIQUE NOT NULL,
          name VARCHAR(255),
          last_message TEXT,
          source_message TEXT,
          source_contact_name VARCHAR(255),
          whatsapp_id VARCHAR(255) UNIQUE,
          status VARCHAR(20) DEFAULT 'new' CHECK (status IN ('new', 'potential', 'won', 'lost', 'contacted')),
          source VARCHAR(50) DEFAULT 'whatsapp' CHECK (source IN ('whatsapp', 'manual')),
          value DECIMAL(10, 2) DEFAULT 0 CHECK (value >= 0),
          product_name VARCHAR(255),
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW()
        );

        CREATE INDEX IF NOT EXISTS idx_phone ON leads(phone);
        CREATE INDEX IF NOT EXISTS idx_status ON leads(status);
        CREATE INDEX IF NOT EXISTS idx_created_at ON leads(created_at DESC);
        CREATE INDEX IF NOT EXISTS idx_whatsapp_id ON leads(whatsapp_id);
      `;

        await client.query(createTableQuery);

        // Add constraint if not exists (for id parameter type)
        try {
            await client.query(`
                ALTER TABLE leads ALTER COLUMN id SET DATA TYPE UUID USING id::uuid;
            `);
        } catch (e) {
            // Column might already be UUID type, ignore
        }

        await client.query('COMMIT');
        console.log('âœ… Database tables initialized successfully');
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('âŒ Error initializing database:', error.message);
        throw error;
    } finally {
        client.release();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VALIDATION HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function validatePhone(phone) {
    if (!phone) {
        throw new Error('Phone number is required');
    }
    // Remove all non-digit characters
    const cleaned = phone.replace(/\D/g, '');
    // Check if valid phone number (8-15 digits)
    if (cleaned.length < 8 || cleaned.length > 15) {
        throw new Error(`Invalid phone number: ${phone}`);
    }
    return cleaned;
}

function validateStatus(status) {
    const validStatuses = ['new', 'potential', 'won', 'lost', 'contacted'];
    if (!validStatuses.includes(status)) {
        throw new Error(`Invalid status: ${status}. Must be one of: ${validStatuses.join(', ')}`);
    }
    return status;
}

function validateValue(value) {
    if (value !== undefined && value !== null && value !== '') {
        const numValue = parseFloat(value);
        if (isNaN(numValue) || numValue < 0) {
            throw new Error('Value must be a non-negative number');
        }
        return numValue;
    }
    return 0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRUD OPERATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Create or update a lead (Upsert operation with transaction)
 */
async function createLead(data) {
    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        // Validate inputs
        const cleanedPhone = validatePhone(data.phone);
        const status = validateStatus(data.status || 'new');
        const value = validateValue(data.value);

        const {
            name,
            last_message,
            source_message,
            source_contact_name,
            whatsapp_id,
            source = 'whatsapp',
            product_name
        } = data;

        // Upsert with full UPDATE (not DO NOTHING)
        const query = `
        INSERT INTO leads (
          phone, name, last_message, source_message, source_contact_name,
          whatsapp_id, status, source, value, product_name
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        ON CONFLICT (phone) 
        DO UPDATE SET
          name = COALESCE(EXCLUDED.name, leads.name),
          last_message = COALESCE(EXCLUDED.last_message, leads.last_message),
          source_message = COALESCE(EXCLUDED.source_message, leads.source_message),
          source_contact_name = COALESCE(EXCLUDED.source_contact_name, leads.source_contact_name),
          whatsapp_id = COALESCE(EXCLUDED.whatsapp_id, leads.whatsapp_id),
          value = COALESCE(EXCLUDED.value, leads.value),
          product_name = COALESCE(EXCLUDED.product_name, leads.product_name),
          updated_at = NOW()
        RETURNING *;
      `;

        const values = [
            cleanedPhone,
            name || null,
            last_message || null,
            source_message || null,
            source_contact_name || null,
            whatsapp_id || null,
            status,
            source,
            value,
            product_name || null
        ];

        const result = await client.query(query, values);
        await client.query('COMMIT');

        console.log(`âœ… Lead upserted: ${cleanedPhone} (${result.rows[0].status})`);
        return result.rows[0];
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('âŒ Error creating lead:', error.message);
        throw error;
    } finally {
        client.release();
    }
}

/**
 * Find lead by phone number
 */
async function findLeadByPhone(phone) {
    try {
        const cleanedPhone = validatePhone(phone);
        const query = 'SELECT * FROM leads WHERE phone = $1';
        const result = await pool.query(query, [cleanedPhone]);
        return result.rows[0] || null;
    } catch (error) {
        console.error('âŒ Error finding lead:', error.message);
        throw error;
    }
}

/**
 * Find lead by WhatsApp ID
 */
async function findLeadByWhatsAppId(whatsappId) {
    try {
        if (!whatsappId) return null;
        const query = 'SELECT * FROM leads WHERE whatsapp_id = $1';
        const result = await pool.query(query, [whatsappId]);
        return result.rows[0] || null;
    } catch (error) {
        console.error('âŒ Error finding lead by WhatsApp ID:', error.message);
        throw error;
    }
}

/**
 * Update lead message and metadata (with transaction)
 */
async function updateLeadMessage(phone, message, whatsappId, name = null) {
    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        const cleanedPhone = validatePhone(phone);

        const query = `
        UPDATE leads
        SET last_message = $1, 
            whatsapp_id = COALESCE($2, whatsapp_id),
            name = COALESCE($3, name),
            updated_at = NOW()
        WHERE phone = $4
        RETURNING *;
      `;

        const result = await client.query(query, [message || null, whatsappId || null, name || null, cleanedPhone]);
        await client.query('COMMIT');

        if (result.rows.length === 0) {
            console.warn(`âš ï¸ No lead found to update: ${cleanedPhone}`);
            return null;
        }

        console.log(`âœ… Lead message updated: ${cleanedPhone}`);
        return result.rows[0];
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('âŒ Error updating lead message:', error.message);
        throw error;
    } finally {
        client.release();
    }
}

/**
 * Update lead status (with validation and transaction)
 */
async function updateLeadStatus(id, status) {
    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        const validStatus = validateStatus(status);

        const query = `
        UPDATE leads
        SET status = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING *;
      `;

        const result = await client.query(query, [validStatus, id]);
        await client.query('COMMIT');

        if (result.rows.length === 0) {
            console.warn(`âš ï¸ No lead found to update status: ${id}`);
            return null;
        }

        console.log(`âœ… Lead status updated: ${id} -> ${validStatus}`);
        return result.rows[0];
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('âŒ Error updating lead status:', error.message);
        throw error;
    } finally {
        client.release();
    }
}

/**
 * Update lead value
 */
async function updateLeadValue(id, value) {
    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        const validValue = validateValue(value);

        const query = `
        UPDATE leads
        SET value = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING *;
      `;

        const result = await client.query(query, [validValue, id]);
        await client.query('COMMIT');

        if (result.rows.length === 0) {
            console.warn(`âš ï¸ No lead found to update value: ${id}`);
            return null;
        }

        return result.rows[0];
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('âŒ Error updating lead value:', error.message);
        throw error;
    } finally {
        client.release();
    }
}

/**
 * Get all leads with optional filters (improved with pagination)
 */
async function getLeads(filters = {}) {
    try {
        let query = 'SELECT * FROM leads WHERE 1=1';
        const values = [];
        let paramCount = 1;

        if (filters.status) {
            const validStatus = validateStatus(filters.status);
            query += ` AND status = $${paramCount}`;
            values.push(validStatus);
            paramCount++;
        }

        if (filters.startDate) {
            query += ` AND created_at >= $${paramCount}`;
            values.push(filters.startDate);
            paramCount++;
        }

        if (filters.endDate) {
            query += ` AND created_at <= $${paramCount}`;
            values.push(filters.endDate);
            paramCount++;
        }

        if (filters.search) {
            query += ` AND (name ILIKE $${paramCount} OR phone ILIKE $${paramCount} OR last_message ILIKE $${paramCount})`;
            values.push(`%${filters.search}%`);
            paramCount++;
        }

        query += ' ORDER BY created_at DESC';

        if (filters.limit) {
            query += ` LIMIT $${paramCount}`;
            values.push(filters.limit);
        }

        if (filters.offset) {
            paramCount++;
            query += ` OFFSET $${paramCount}`;
            values.push(filters.offset);
        }

        const result = await pool.query(query, values);
        return result.rows;
    } catch (error) {
        console.error('âŒ Error getting leads:', error.message);
        throw error;
    }
}

/**
 * Delete lead (with transaction)
 */
async function deleteLead(id) {
    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        const query = 'DELETE FROM leads WHERE id = $1 RETURNING *';
        const result = await client.query(query, [id]);
        await client.query('COMMIT');

        if (result.rows.length === 0) {
            console.warn(`âš ï¸ No lead found to delete: ${id}`);
            return null;
        }

        console.log(`âœ… Lead deleted: ${id}`);
        return result.rows[0];
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('âŒ Error deleting lead:', error.message);
        throw error;
    } finally {
        client.release();
    }
}

/**
 * Get lead statistics with improved query
 */
async function getLeadStats() {
    try {
        const query = `
        SELECT 
          COUNT(*) as total,
          COUNT(*) FILTER (WHERE status = 'new') as new,
          COUNT(*) FILTER (WHERE status = 'potential') as potential,
          COUNT(*) FILTER (WHERE status = 'contacted') as contacted,
          COUNT(*) FILTER (WHERE status = 'won') as won,
          COUNT(*) FILTER (WHERE status = 'lost') as lost,
          COALESCE(SUM(value) FILTER (WHERE status = 'won'), 0) as total_won_value,
          COALESCE(AVG(value) FILTER (WHERE status = 'won'), 0) as avg_won_value
        FROM leads;
      `;

        const result = await pool.query(query);
        const stats = result.rows[0];

        console.log(`ğŸ“Š Lead stats: ${stats.total} total, ${stats.won} won, ${stats.potential} potential`);
        return stats;
    } catch (error) {
        console.error('âŒ Error getting lead stats:', error.message);
        throw error;
    }
}

/**
 * Get leads by status for dashboard
 */
async function getLeadsByStatus(status) {
    try {
        const validStatus = validateStatus(status);
        const query = 'SELECT * FROM leads WHERE status = $1 ORDER BY updated_at DESC LIMIT 50';
        const result = await pool.query(query, [validStatus]);
        return result.rows;
    } catch (error) {
        console.error('âŒ Error getting leads by status:', error.message);
        throw error;
    }
}

/**
 * Health check for database
 */
async function healthCheck() {
    try {
        const result = await pool.query('SELECT 1 as health');
        return {
            status: 'healthy',
            totalCount: pool.totalCount,
            idleCount: pool.idleCount,
            waitingCount: pool.waitingCount
        };
    } catch (error) {
        return {
            status: 'unhealthy',
            error: error.message
        };
    }
}

/**
 * Graceful shutdown
 */
async function closePool() {
    try {
        await pool.end();
        console.log('âœ… Database connection pool closed');
    } catch (error) {
        console.error('âŒ Error closing database pool:', error.message);
    }
}

// Handle process termination
process.on('SIGINT', async () => {
    console.log('\nğŸ›‘ Received SIGINT, closing database connection...');
    await closePool();
    process.exit(0);
});

process.on('SIGTERM', async () => {
    console.log('\nğŸ›‘ Received SIGTERM, closing database connection...');
    await closePool();
    process.exit(0);
});

module.exports = {
    pool,
    initDb,
    createLead,
    findLeadByPhone,
    findLeadByWhatsAppId,
    updateLeadMessage,
    updateLeadStatus,
    updateLeadValue,
    getLeads,
    deleteLead,
    getLeadStats,
    getLeadsByStatus,
    healthCheck,
    closePool
};
